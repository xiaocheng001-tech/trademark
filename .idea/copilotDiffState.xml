<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Trademark detection/app/core/detector.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Trademark detection/app/core/detector.py" />
              <option name="originalContent" value="import cv2&#10;import numpy as np&#10;import os&#10;from ..common.logger import LogManager&#10;from typing import List, Dict, Optional, Tuple&#10;from ultralytics import YOLO&#10;&#10;&#10;class TrademarkDetector:&#10;    &quot;&quot;&quot;基于YOLO模型的商标检测器&quot;&quot;&quot;&#10;&#10;    def __init__(self, logger: Optional[LogManager] = None):&#10;        self.model = None  # YOLO模型实例&#10;        self.logger = logger # 日志&#10;        self.model_path = os.path.join(&#10;            os.path.dirname(os.path.dirname(os.path.dirname(__file__))),&#10;            &quot;app&quot;, &quot;appdata&quot;, &quot;model&quot;, &quot;best.pt&quot;&#10;        ) # 模型路径&#10;        self.product_type = &quot;product1&quot;  # 默认产品类型&#10;        self._load_model()  # 加载YOLO模型&#10;&#10;    def set_product_type(self, product_type: str):&#10;        &quot;&quot;&quot;设置产品类型&quot;&quot;&quot;&#10;        self.product_type = product_type&#10;        if self.logger:&#10;            self.logger.info(f&quot;检测器产品类型设置为: {product_type}&quot;)&#10;&#10;    def get_product_requirements(self):&#10;        &quot;&quot;&quot;获取当前产品的检测要求&quot;&quot;&quot;&#10;        if self.product_type == &quot;product1&quot;:&#10;            return {&#10;                &quot;required_classes&quot;: [2, 4],  # 需要类别2(ok1)和类别4(魔术贴)&#10;                &quot;description&quot;: &quot;产品一：ok1商标+魔术贴&quot;&#10;            }&#10;        elif self.product_type == &quot;product2&quot;:&#10;            return {&#10;                &quot;required_classes&quot;: [2, 3, 4],  # 需要类别2(ok1)、类别3(ok2)和类别4(魔术贴)&#10;                &quot;description&quot;: &quot;产品二：ok1+ok2商标+魔术贴&quot;&#10;            }&#10;        else:&#10;            # 默认产品一&#10;            return {&#10;                &quot;required_classes&quot;: [2, 4],&#10;                &quot;description&quot;: &quot;默认：ok1商标+魔术贴&quot;&#10;            }&#10;&#10;    def _load_model(self):&#10;        &quot;&quot;&quot;加载YOLO模型&quot;&quot;&quot;&#10;        try:&#10;            if os.path.exists(self.model_path):  # 检查模型文件是否存在&#10;                self.model = YOLO(self.model_path)  # 加载YOLO模型&#10;                self.logger.info(f&quot;YOLO模型加载成功: {self.model_path}&quot;)  # 日志记录模型加载成功&#10;            else:&#10;                self.logger.error(f&quot;YOLO模型文件不存在: {self.model_path}&quot;)&#10;                raise FileNotFoundError(f&quot;模型文件不存在: {self.model_path}&quot;)&#10;        except Exception as e:&#10;            self.logger.error(f&quot;加载YOLO模型失败: {str(e)}&quot;)&#10;            raise&#10;&#10;    def detect_in_image(self, image: np.ndarray) -&gt; List[Dict]:&#10;        &quot;&quot;&quot;&#10;        使用YOLO模型检测图像中的对象&#10;        &#10;        类别定义:&#10;        - 0, 1: 标签颠倒 (需要报警)&#10;        - 2, 3: 正常标签&#10;        - 4: 魔术贴&#10;        &#10;        报警逻辑:&#10;        - 只有正常标签(2,3)和魔术贴(4)都存在时才不报警&#10;        - 检测到颠倒标签(0,1)时报警&#10;        - 没有魔术贴(4)时报警&#10;        &quot;&quot;&quot;&#10;        if image is None:  # 检查图像是否有效&#10;            return []&#10;&#10;        if self.model is None:  # 检查模型是否已加载&#10;            self.logger.error(&quot;YOLO模型未加载&quot;)&#10;            return []&#10;&#10;        try:&#10;            # 使用YOLO模型进行推理&#10;            results = self.model.predict(image)  # 预测图像中的对象&#10;            boxes = []&#10;            for result in results:&#10;                boxes = result.boxes.data.tolist()&#10;&#10;            filtered_boxes = []  # 用于存储过滤后的检测框&#10;            if boxes:  # 检查是否有检测结果&#10;                # 按类别分组&#10;                class_groups = {&#10;                    'group_02': [],  # 类别0和2 0: ng1, 2: ok1 小商标&#10;                    'group_13': [],  # 类别1和3 1: ng2, 3: ok2 大商标&#10;                    'other': []      # 其他类别 4: 魔术贴&#10;                }&#10;                &#10;                for box in boxes:&#10;                    class_id = int(box[5])  # 获取类别ID&#10;                    &#10;                    if class_id in [0, 2]:  # 类别0和2&#10;                        class_groups['group_02'].append(box)  # 小商标检测框加入到 group_02&#10;                    elif class_id in [1, 3]:  # 类别1和3&#10;                        class_groups['group_13'].append(box)  # 大商标检测框加入到 group_13&#10;                    else:  # 其他类别 魔术贴&#10;                        class_groups['other'].append(box)  # 魔术贴检测框加入到 other&#10;                &#10;                # 对每个组应用NMS，只有当多个框指向同一个位置时才选择置信度最大的留下&#10;                for group_name, group_boxes in class_groups.items():  # 从class_groups中获取每个组的检测框&#10;                    if group_boxes:&#10;                        if group_name in ['group_02', 'group_13']:&#10;                            # 对于0,2组合和1,3组合，应用NMS&#10;                            nms_boxes = self._apply_nms_to_group(group_boxes, iou_threshold=0.5)&#10;                            filtered_boxes.extend(nms_boxes)  # 将NMS处理后的检测框添加到filtered_boxes&#10;                        else:&#10;                            # 对于其他类别，按相同class_id分组，每组应用NMS&#10;                            same_class_groups = {}&#10;                            for box in group_boxes:&#10;                                class_id = int(box[5])&#10;                                if class_id not in same_class_groups:&#10;                                    same_class_groups[class_id] = []&#10;                                same_class_groups[class_id].append(box)&#10;                            &#10;                            for class_id, same_class_boxes in same_class_groups.items():&#10;                                nms_boxes = self._apply_nms_to_group(same_class_boxes, iou_threshold=0.5)&#10;                                filtered_boxes.extend(nms_boxes)&#10;                &#10;                boxes = filtered_boxes&#10;                self.logger.info(f&quot;NMS过滤后保留 {len(boxes)} 个检测框&quot;)&#10;            &#10;            detections = []&#10;            class_counts = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0}&#10;            &#10;            # 处理检测结果&#10;            for box in boxes:&#10;                # 获取边界框坐标&#10;                x1, y1, x2, y2 = box[0], box[1], box[2], box[3]&#10;                confidence = box[4]&#10;                class_id = int(box[5])&#10;                # 过滤掉置信度低于0.5并且不是魔术贴的检测结果&#10;                if class_id != 4 and confidence &lt; 0.8:&#10;                    continue&#10;&#10;                elif class_id == 4 and confidence &lt; 0.6:&#10;                    continue&#10;&#10;                # 统计各类别数量&#10;                if class_id in class_counts:&#10;                    class_counts[class_id] += 1&#10;&#10;                # 确定检测类型和状态&#10;                detection_type, status, color = self._analyze_detection_class(class_id)&#10;&#10;                detection = {&#10;                    'class_id': class_id,  # 类别ID&#10;                    'detection_type': detection_type,  # 检测类型&#10;                    'confidence': float(confidence),  # 置信度&#10;                    'bbox': [int(x1), int(y1), int(x2), int(y2)],  # 边界框坐标&#10;                    'location': (int(x1), int(y1)),  # 左上角坐标&#10;                    'size': (int(x2 - x1), int(y2 - y1)),  # 检测框大小&#10;                    'status': status,  # 检测状态&#10;                    'color': color,  # 绘制边界框的颜色&#10;                    'method': 'yolo_detection'  # 检测方法&#10;                }&#10;&#10;                detections.append(detection)&#10;                self.logger.info(f&quot;检测到 {detection_type} (类别{class_id}), 置信度: {confidence:.3f}&quot;)&#10;            &#10;            # 分析整体状态&#10;            analyzed_results = self._analyze_overall_status(detections, class_counts)&#10;            &#10;            return analyzed_results&#10;            &#10;            # 播放检测完成的语音提示（最高优先级）&#10;            self.voice_alarm.trigger_completion_voice()&#10;            &#10;        except Exception as e:&#10;            self.logger.error(f&quot;YOLO检测失败: {str(e)}&quot;)&#10;            return []&#10;&#10;    def _calculate_iou(self, box1, box2) -&gt; float:&#10;        &quot;&quot;&quot;&#10;        计算两个检测框的IoU (Intersection over Union)&#10;        &#10;        Args:&#10;            box1, box2: 检测框 [x1, y1, x2, y2, confidence, class_id]&#10;            &#10;        Returns:&#10;            IoU值 (0-1之间)&#10;        &quot;&quot;&quot;&#10;        # 获取坐标&#10;        x1_1, y1_1, x2_1, y2_1 = box1[0], box1[1], box1[2], box1[3]&#10;        x1_2, y1_2, x2_2, y2_2 = box2[0], box2[1], box2[2], box2[3]&#10;        &#10;        # 计算交集区域&#10;        x1_inter = max(x1_1, x1_2)&#10;        y1_inter = max(y1_1, y1_2)&#10;        x2_inter = min(x2_1, x2_2)&#10;        y2_inter = min(y2_1, y2_2)&#10;        &#10;        # 如果没有交集，返回0&#10;        if x2_inter &lt;= x1_inter or y2_inter &lt;= y1_inter:&#10;            return 0.0&#10;        &#10;        # 计算交集面积&#10;        inter_area = (x2_inter - x1_inter) * (y2_inter - y1_inter)&#10;        &#10;        # 计算两个框的面积&#10;        area1 = (x2_1 - x1_1) * (y2_1 - y1_1)&#10;        area2 = (x2_2 - x1_2) * (y2_2 - y1_2)&#10;        &#10;        # 计算并集面积&#10;        union_area = area1 + area2 - inter_area&#10;        &#10;        # 避免除零&#10;        if union_area == 0:&#10;            return 0.0&#10;        &#10;        return inter_area / union_area&#10;&#10;    def _apply_nms_to_group(self, group_boxes, iou_threshold=0.5):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            group_boxes: 检测框列表&#10;            iou_threshold: IoU阈值，超过此值认为是重叠框&#10;        Returns:&#10;            经过NMS处理的检测框列表&#10;        &quot;&quot;&quot;&#10;        if len(group_boxes) &lt;= 1:  # 如果只有一个框或没有框，直接返回&#10;            return group_boxes&#10;        &#10;        # 按置信度降序排序&#10;        sorted_boxes = sorted(group_boxes, key=lambda x: x[4], reverse=True)&#10;        &#10;        # 保留置信度最高的框&#10;        keep_boxes = [sorted_boxes[0]]&#10;&#10;        # 处理剩余的框&#10;        for candidate_box in sorted_boxes[1:]:&#10;            # 检查候选框是否与任何已保留的框重叠&#10;            should_keep = True&#10;            for kept_box in keep_boxes:&#10;                iou = self._calculate_iou(candidate_box, kept_box)&#10;                if iou &gt;= iou_threshold:&#10;                    # 如果与任何已保留框重叠，则丢弃&#10;                    should_keep = False&#10;                    break&#10;            &#10;            # 如果与所有已保留框都不重叠，则保留&#10;            if should_keep:&#10;                keep_boxes.append(candidate_box)&#10;        &#10;        return keep_boxes&#10;&#10;    def _analyze_detection_class(self, class_id: int) -&gt; Tuple[str, str, Tuple[int, int, int]]:&#10;        &quot;&quot;&quot;&#10;        分析检测类别并返回类型、状态和颜色&#10;        &#10;        Args:&#10;            class_id: YOLO检测的类别ID&#10;            &#10;        Returns:&#10;            Tuple[检测类型, 状态, 颜色(BGR)]&#10;        &quot;&quot;&quot;&#10;        if class_id in [0, 1]:&#10;            return &quot;label&quot;, &quot;ng&quot;, (0, 0, 255)  # 红色，颠倒的商标视为NG&#10;        if class_id in [2, 3]:&#10;            return &quot;label&quot;, &quot;ok&quot;, (0, 255, 0)  # 绿色，正常商标&#10;        if class_id == 4:&#10;            return &quot;velcro&quot;, &quot;ok&quot;, (0, 255, 0)  # 绿色，魔术贴&#10;        return None&#10;&#10;    def _analyze_overall_status(self, detections: List[Dict], class_counts: Dict[int, int]) -&gt; List[Dict]:&#10;        &quot;&quot;&quot;&#10;        分析整体检测状态并更新每个检测结果&#10;        &#10;        Args:&#10;            detections: 检测结果列表&#10;            class_counts: 各类别计数&#10;            &#10;        Returns:&#10;            更新后的检测结果列表&#10;        &quot;&quot;&quot;&#10;        # 获取当前产品要求&#10;        requirements = self.get_product_requirements()&#10;        required_classes = requirements[&quot;required_classes&quot;]&#10;&#10;        # 统计各类型数量&#10;        inverted_count = class_counts[0] + class_counts[1]  # 颠倒标签&#10;        ok1_count = class_counts[2]  # ok1商标 (类别2)&#10;        ok2_count = class_counts[3]  # ok2商标 (类别3)&#10;        velcro_count = class_counts[4]  # 魔术贴&#10;&#10;        overall_status = 'ok'  # 整体状态，默认OK&#10;        defect_reasons = []  # 缺陷原因列表&#10;&#10;        # 检查是否有颠倒标签&#10;        if inverted_count &gt; 0:&#10;            overall_status = 'ng'&#10;            defect_reasons.append('商标颠倒')&#10;&#10;        # 根据产品类型检查必需的组件&#10;        if self.product_type == &quot;product1&quot;:&#10;            # 产品一：需要ok1商标(类别2)和魔术贴(类别4)&#10;            if ok1_count == 0:&#10;                overall_status = 'ng'&#10;                defect_reasons.append('商标缺失')&#10;            if velcro_count == 0:&#10;                overall_status = 'ng'&#10;                defect_reasons.append('魔术贴缺失')&#10;&#10;        elif self.product_type == &quot;product2&quot;:&#10;            # 产品二：需要ok1商标(类别2)、ok2商标(类别3)和魔术贴(类别4)&#10;            if ok1_count == 0:&#10;                overall_status = 'ng'&#10;                defect_reasons.append('商标缺失')&#10;            if ok2_count == 0:&#10;                overall_status = 'ng'&#10;                defect_reasons.append('商标缺失')&#10;            if velcro_count == 0:&#10;                overall_status = 'ng'&#10;                defect_reasons.append('魔术贴缺失')&#10;&#10;        # 创建分析结果&#10;        analysis_result = {&#10;            'overall_status': overall_status,  # 整体状态&#10;            'defect_reasons': defect_reasons,  # 缺陷原因&#10;            'inverted_count': inverted_count,  # 颠倒标签数量&#10;            'ok1_count': ok1_count,  # ok1商标数量&#10;            'ok2_count': ok2_count,  # ok2商标数量&#10;            'velcro_count': velcro_count,  # 魔术贴数量&#10;            'total_detections': len(detections),  # 总检测数量&#10;            'product_type': self.product_type,  # 产品类型&#10;            'required_classes': required_classes  # 必需的类别&#10;        }&#10;        &#10;        # 记录详细的检测信息&#10;        if self.logger:&#10;            self.logger.info(f&quot;产品类型: {self.product_type}&quot;)&#10;            self.logger.info(f&quot;检测到: ok1={ok1_count}, ok2={ok2_count}, 魔术贴={velcro_count}, 颠倒={inverted_count}&quot;)&#10;            self.logger.info(f&quot;整体状态: {overall_status}&quot;)&#10;            if defect_reasons:&#10;                self.logger.info(f&quot;缺陷原因: {', '.join(defect_reasons)}&quot;)&#10;&#10;        # 根据整体状态更新每个检测结果&#10;        for detection in detections:&#10;            class_id = detection['class_id']  # 获取类别ID&#10;            &#10;            if class_id in [0, 1]:  # 颠倒标签&#10;                detection['status'] = 'ng'&#10;                detection['color'] = (0, 0, 255)  # 红色&#10;                detection['defect_type'] = '商标颠倒'&#10;                detection['reason'] = '商标颠倒'&#10;            elif class_id in [2, 3]:  # 正常标签&#10;                detection['status'] = 'ok' if overall_status == 'ok' else 'ng'&#10;                detection['color'] = (0, 255, 0) if overall_status == 'ok' else (0, 0, 255)&#10;                # 根据检测结果设置缺陷类型&#10;                if overall_status == 'ok':&#10;                    detection['defect_type'] = None&#10;                    detection['reason'] = None&#10;                else:&#10;                    detection['defect_type'] = ', '.join(defect_reasons) if defect_reasons else '未知缺陷'&#10;                    detection['reason'] = detection['defect_type']&#10;            elif class_id == 4:  # 魔术贴&#10;                detection['status'] = 'ok' if overall_status == 'ok' else 'ng'&#10;                detection['color'] = (0, 255, 0) if overall_status == 'ok' else (0, 0, 255)&#10;                # 根据检测结果设置缺陷类型&#10;                if overall_status == 'ok':&#10;                    detection['defect_type'] = None&#10;                    detection['reason'] = None&#10;                else:&#10;                    detection['defect_type'] = ', '.join(defect_reasons) if defect_reasons else '未知缺陷'&#10;                    detection['reason'] = detection['defect_type']&#10;            else:&#10;                # 其他类别（不期望出现），统一按NG处理&#10;                detection['status'] = 'ng'&#10;                detection['color'] = (0, 0, 255)&#10;                detection['defect_type'] = '未知缺陷'&#10;                detection['reason'] = '未知缺陷'&#10;            &#10;            # 添加分析结果到每个检测&#10;            detection['analysis'] = analysis_result&#10;        &#10;        return detections&#10;&#10;    def draw_results(self, image: np.ndarray, results: List[Dict]) -&gt; np.ndarray:&#10;        &quot;&quot;&quot;在图像上绘制YOLO检测结果&quot;&quot;&quot;&#10;        img_result = image.copy()&#10;        &#10;        for result in results:&#10;            color = result.get('color', (0, 255, 0))  # 从结果中获取颜色，如果没有则默认为绿色&#10;            bbox = result['bbox']&#10;            x1, y1, x2, y2 = bbox&#10;            &#10;            # 绘制边界框&#10;            cv2.rectangle(img_result, (x1, y1), (x2, y2), color, 3)&#10;            &#10;            # 准备标签文本&#10;            detection_type = result.get('detection_type', 'Unknown')  # 获取检测类型，如果没有则默认为'Unknown'&#10;            confidence = result.get('confidence', 0.0)  # 获取置信度，如果没有则默认为0.0&#10;            label = f&quot;{detection_type}: {confidence:.2f}&quot;  # 准备标签文本，格式为 &quot;检测类型: 置信度&quot;&#10;            # 绘制标签文字&#10;            cv2.putText(img_result, label, (x1, y1 + 15),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)&#10;        &#10;        return img_result&#10;" />
              <option name="updatedContent" value="import cv2&#10;import numpy as np&#10;import os&#10;from ..common.logger import LogManager&#10;from typing import List, Dict, Optional, Tuple&#10;from ultralytics import YOLO&#10;&#10;&#10;class TrademarkDetector:&#10;    &quot;&quot;&quot;基于YOLO模型的商标检测器&quot;&quot;&quot;&#10;&#10;    def __init__(self, logger: Optional[LogManager] = None):&#10;        self.model = None  # YOLO模型实例&#10;        self.logger = logger # 日志&#10;        self.model_path = os.path.join(&#10;            os.path.dirname(os.path.dirname(os.path.dirname(__file__))),&#10;            &quot;app&quot;, &quot;appdata&quot;, &quot;model&quot;, &quot;best.pt&quot;&#10;        ) # 模型路径&#10;        self.product_type = &quot;product1&quot;  # 默认产品类型&#10;        self._load_model()  # 加载YOLO模型&#10;&#10;    def set_product_type(self, product_type: str):&#10;        &quot;&quot;&quot;设置产品类型&quot;&quot;&quot;&#10;        self.product_type = product_type&#10;        if self.logger:&#10;            self.logger.info(f&quot;检测器产品类型设置为: {product_type}&quot;)&#10;&#10;    def set_completion_voice_enabled(self, enabled: bool):&#10;        &quot;&quot;&quot;设置检测完成语音开关&quot;&quot;&quot;&#10;        self.voice_alarm.set_completion_voice_enabled(enabled)&#10;        if self.logger:&#10;            status = &quot;启用&quot; if enabled else &quot;禁用&quot;&#10;            self.logger.info(f&quot;检测完成语音已{status}&quot;)&#10;&#10;    def is_completion_voice_enabled(self) -&gt; bool:&#10;        &quot;&quot;&quot;检查检测完成语音是否启用&quot;&quot;&quot;&#10;        return self.voice_alarm.is_completion_voice_enabled()&#10;&#10;    def get_product_requirements(self):&#10;        &quot;&quot;&quot;获取当前产品的检测要求&quot;&quot;&quot;&#10;        if self.product_type == &quot;product1&quot;:&#10;            return {&#10;                &quot;required_classes&quot;: [2, 4],  # 需要类别2(ok1)和类别4(魔术贴)&#10;                &quot;description&quot;: &quot;产品一：ok1商标+魔术贴&quot;&#10;            }&#10;        elif self.product_type == &quot;product2&quot;:&#10;            return {&#10;                &quot;required_classes&quot;: [2, 3, 4],  # 需要类别2(ok1)、类别3(ok2)和类别4(魔术贴)&#10;                &quot;description&quot;: &quot;产品二：ok1+ok2商标+魔术贴&quot;&#10;            }&#10;        else:&#10;            # 默认产品一&#10;            return {&#10;                &quot;required_classes&quot;: [2, 4],&#10;                &quot;description&quot;: &quot;默认：ok1商标+魔术贴&quot;&#10;            }&#10;&#10;    def _load_model(self):&#10;        &quot;&quot;&quot;加载YOLO模型&quot;&quot;&quot;&#10;        try:&#10;            if os.path.exists(self.model_path):  # 检查模型文件是否存在&#10;                self.model = YOLO(self.model_path)  # 加载YOLO模型&#10;                self.logger.info(f&quot;YOLO模型加载成功: {self.model_path}&quot;)  # 日志记录模型加载成功&#10;            else:&#10;                self.logger.error(f&quot;YOLO模型文件不存在: {self.model_path}&quot;)&#10;                raise FileNotFoundError(f&quot;模型文件不存在: {self.model_path}&quot;)&#10;        except Exception as e:&#10;            self.logger.error(f&quot;加载YOLO模型失败: {str(e)}&quot;)&#10;            raise&#10;&#10;    def detect_in_image(self, image: np.ndarray) -&gt; List[Dict]:&#10;        &quot;&quot;&quot;&#10;        使用YOLO模型检测图像中的对象&#10;        &#10;        类别定义:&#10;        - 0, 1: 标签颠倒 (需要报警)&#10;        - 2, 3: 正常标签&#10;        - 4: 魔术贴&#10;        &#10;        报警逻辑:&#10;        - 只有正常标签(2,3)和魔术贴(4)都存在时才不报警&#10;        - 检测到颠倒标签(0,1)时报警&#10;        - 没有魔术贴(4)时报警&#10;        &quot;&quot;&quot;&#10;        if image is None:  # 检查图像是否有效&#10;            return []&#10;&#10;        if self.model is None:  # 检查模型是否已加载&#10;            self.logger.error(&quot;YOLO模型未加载&quot;)&#10;            return []&#10;&#10;        try:&#10;            # 使用YOLO模型进行推理&#10;            results = self.model.predict(image)  # 预测图像中的对象&#10;            boxes = []&#10;            for result in results:&#10;                boxes = result.boxes.data.tolist()&#10;&#10;            filtered_boxes = []  # 用于存储过滤后的检测框&#10;            if boxes:  # 检查是否有检测结果&#10;                # 按类别分组&#10;                class_groups = {&#10;                    'group_02': [],  # 类别0和2 0: ng1, 2: ok1 小商标&#10;                    'group_13': [],  # 类别1和3 1: ng2, 3: ok2 大商标&#10;                    'other': []      # 其他类别 4: 魔术贴&#10;                }&#10;                &#10;                for box in boxes:&#10;                    class_id = int(box[5])  # 获取类别ID&#10;                    &#10;                    if class_id in [0, 2]:  # 类别0和2&#10;                        class_groups['group_02'].append(box)  # 小商标检测框加入到 group_02&#10;                    elif class_id in [1, 3]:  # 类别1和3&#10;                        class_groups['group_13'].append(box)  # 大商标检测框加入到 group_13&#10;                    else:  # 其他类别 魔术贴&#10;                        class_groups['other'].append(box)  # 魔术贴检测框加入到 other&#10;                &#10;                # 对每个组应用NMS，只有当多个框指向同一个位置时才选择置信度最大的留下&#10;                for group_name, group_boxes in class_groups.items():  # 从class_groups中获取每个组的检测框&#10;                    if group_boxes:&#10;                        if group_name in ['group_02', 'group_13']:&#10;                            # 对于0,2组合和1,3组合，应用NMS&#10;                            nms_boxes = self._apply_nms_to_group(group_boxes, iou_threshold=0.5)&#10;                            filtered_boxes.extend(nms_boxes)  # 将NMS处理后的检测框添加到filtered_boxes&#10;                        else:&#10;                            # 对于其他类别，按相同class_id分组，每组应用NMS&#10;                            same_class_groups = {}&#10;                            for box in group_boxes:&#10;                                class_id = int(box[5])&#10;                                if class_id not in same_class_groups:&#10;                                    same_class_groups[class_id] = []&#10;                                same_class_groups[class_id].append(box)&#10;                            &#10;                            for class_id, same_class_boxes in same_class_groups.items():&#10;                                nms_boxes = self._apply_nms_to_group(same_class_boxes, iou_threshold=0.5)&#10;                                filtered_boxes.extend(nms_boxes)&#10;                &#10;                boxes = filtered_boxes&#10;                self.logger.info(f&quot;NMS过滤后保留 {len(boxes)} 个检测框&quot;)&#10;            &#10;            detections = []&#10;            class_counts = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0}&#10;            &#10;            # 处理检测结果&#10;            for box in boxes:&#10;                # 获取边界框坐标&#10;                x1, y1, x2, y2 = box[0], box[1], box[2], box[3]&#10;                confidence = box[4]&#10;                class_id = int(box[5])&#10;                # 过滤掉置信度低于0.5并且不是魔术贴的检测结果&#10;                if class_id != 4 and confidence &lt; 0.8:&#10;                    continue&#10;&#10;                elif class_id == 4 and confidence &lt; 0.6:&#10;                    continue&#10;&#10;                # 统计各类别数量&#10;                if class_id in class_counts:&#10;                    class_counts[class_id] += 1&#10;&#10;                # 确定检测类型和状态&#10;                detection_type, status, color = self._analyze_detection_class(class_id)&#10;&#10;                detection = {&#10;                    'class_id': class_id,  # 类别ID&#10;                    'detection_type': detection_type,  # 检测类型&#10;                    'confidence': float(confidence),  # 置信度&#10;                    'bbox': [int(x1), int(y1), int(x2), int(y2)],  # 边界框坐标&#10;                    'location': (int(x1), int(y1)),  # 左上角坐标&#10;                    'size': (int(x2 - x1), int(y2 - y1)),  # 检测框大小&#10;                    'status': status,  # 检测状态&#10;                    'color': color,  # 绘制边界框的颜色&#10;                    'method': 'yolo_detection'  # 检测方法&#10;                }&#10;&#10;                detections.append(detection)&#10;                self.logger.info(f&quot;检测到 {detection_type} (类别{class_id}), 置信度: {confidence:.3f}&quot;)&#10;            &#10;            # 分析整体状态&#10;            analyzed_results = self._analyze_overall_status(detections, class_counts)&#10;            &#10;            return analyzed_results&#10;            &#10;            # 播放检测完成的语音提示（最高优先级）&#10;            self.voice_alarm.trigger_completion_voice()&#10;            &#10;        except Exception as e:&#10;            self.logger.error(f&quot;YOLO检测失败: {str(e)}&quot;)&#10;            return []&#10;&#10;    def _calculate_iou(self, box1, box2) -&gt; float:&#10;        &quot;&quot;&quot;&#10;        计算两个检测框的IoU (Intersection over Union)&#10;        &#10;        Args:&#10;            box1, box2: 检测框 [x1, y1, x2, y2, confidence, class_id]&#10;            &#10;        Returns:&#10;            IoU值 (0-1之间)&#10;        &quot;&quot;&quot;&#10;        # 获取坐标&#10;        x1_1, y1_1, x2_1, y2_1 = box1[0], box1[1], box1[2], box1[3]&#10;        x1_2, y1_2, x2_2, y2_2 = box2[0], box2[1], box2[2], box2[3]&#10;        &#10;        # 计算交集区域&#10;        x1_inter = max(x1_1, x1_2)&#10;        y1_inter = max(y1_1, y1_2)&#10;        x2_inter = min(x2_1, x2_2)&#10;        y2_inter = min(y2_1, y2_2)&#10;        &#10;        # 如果没有交集，返回0&#10;        if x2_inter &lt;= x1_inter or y2_inter &lt;= y1_inter:&#10;            return 0.0&#10;        &#10;        # 计算交集面积&#10;        inter_area = (x2_inter - x1_inter) * (y2_inter - y1_inter)&#10;        &#10;        # 计算两个框的面积&#10;        area1 = (x2_1 - x1_1) * (y2_1 - y1_1)&#10;        area2 = (x2_2 - x1_2) * (y2_2 - y1_2)&#10;        &#10;        # 计算并集面积&#10;        union_area = area1 + area2 - inter_area&#10;        &#10;        # 避免除零&#10;        if union_area == 0:&#10;            return 0.0&#10;        &#10;        return inter_area / union_area&#10;&#10;    def _apply_nms_to_group(self, group_boxes, iou_threshold=0.5):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            group_boxes: 检测框列表&#10;            iou_threshold: IoU阈值，超过此值认为是重叠框&#10;        Returns:&#10;            经过NMS处理的检测框列表&#10;        &quot;&quot;&quot;&#10;        if len(group_boxes) &lt;= 1:  # 如果只有一个框或没有框，直接返回&#10;            return group_boxes&#10;        &#10;        # 按置信度降序排序&#10;        sorted_boxes = sorted(group_boxes, key=lambda x: x[4], reverse=True)&#10;        &#10;        # 保留置信度最高的框&#10;        keep_boxes = [sorted_boxes[0]]&#10;&#10;        # 处理剩余的框&#10;        for candidate_box in sorted_boxes[1:]:&#10;            # 检查候选框是否与任何已保留的框重叠&#10;            should_keep = True&#10;            for kept_box in keep_boxes:&#10;                iou = self._calculate_iou(candidate_box, kept_box)&#10;                if iou &gt;= iou_threshold:&#10;                    # 如果与任何已保留框重叠，则丢弃&#10;                    should_keep = False&#10;                    break&#10;            &#10;            # 如果与所有已保留框都不重叠，则保留&#10;            if should_keep:&#10;                keep_boxes.append(candidate_box)&#10;        &#10;        return keep_boxes&#10;&#10;    def _analyze_detection_class(self, class_id: int) -&gt; Tuple[str, str, Tuple[int, int, int]]:&#10;        &quot;&quot;&quot;&#10;        分析检测类别并返回类型、状态和颜色&#10;        &#10;        Args:&#10;            class_id: YOLO检测的类别ID&#10;            &#10;        Returns:&#10;            Tuple[检测类型, 状态, 颜色(BGR)]&#10;        &quot;&quot;&quot;&#10;        if class_id in [0, 1]:&#10;            return &quot;label&quot;, &quot;ng&quot;, (0, 0, 255)  # 红色，颠倒的商标视为NG&#10;        if class_id in [2, 3]:&#10;            return &quot;label&quot;, &quot;ok&quot;, (0, 255, 0)  # 绿色，正常商标&#10;        if class_id == 4:&#10;            return &quot;velcro&quot;, &quot;ok&quot;, (0, 255, 0)  # 绿色，魔术贴&#10;        return None&#10;&#10;    def _analyze_overall_status(self, detections: List[Dict], class_counts: Dict[int, int]) -&gt; List[Dict]:&#10;        &quot;&quot;&quot;&#10;        分析整体检测状态并更新每个检测结果&#10;        &#10;        Args:&#10;            detections: 检测结果列表&#10;            class_counts: 各类别计数&#10;            &#10;        Returns:&#10;            更新后的检测结果列表&#10;        &quot;&quot;&quot;&#10;        # 获取当前产品要求&#10;        requirements = self.get_product_requirements()&#10;        required_classes = requirements[&quot;required_classes&quot;]&#10;&#10;        # 统计各类型数量&#10;        inverted_count = class_counts[0] + class_counts[1]  # 颠倒标签&#10;        ok1_count = class_counts[2]  # ok1商标 (类别2)&#10;        ok2_count = class_counts[3]  # ok2商标 (类别3)&#10;        velcro_count = class_counts[4]  # 魔术贴&#10;&#10;        overall_status = 'ok'  # 整体状态，默认OK&#10;        defect_reasons = []  # 缺陷原因列表&#10;&#10;        # 检查是否有颠倒标签&#10;        if inverted_count &gt; 0:&#10;            overall_status = 'ng'&#10;            defect_reasons.append('商标颠倒')&#10;&#10;        # 根据产品类型检查必需的组件&#10;        if self.product_type == &quot;product1&quot;:&#10;            # 产品一：需要ok1商标(类别2)和魔术贴(类别4)&#10;            if ok1_count == 0:&#10;                overall_status = 'ng'&#10;                defect_reasons.append('商标缺失')&#10;            if velcro_count == 0:&#10;                overall_status = 'ng'&#10;                defect_reasons.append('魔术贴缺失')&#10;&#10;        elif self.product_type == &quot;product2&quot;:&#10;            # 产品二：需要ok1商标(类别2)、ok2商标(类别3)和魔术贴(类别4)&#10;            if ok1_count == 0:&#10;                overall_status = 'ng'&#10;                defect_reasons.append('商标缺失')&#10;            if ok2_count == 0:&#10;                overall_status = 'ng'&#10;                defect_reasons.append('商标缺失')&#10;            if velcro_count == 0:&#10;                overall_status = 'ng'&#10;                defect_reasons.append('魔术贴缺失')&#10;&#10;        # 创建分析结果&#10;        analysis_result = {&#10;            'overall_status': overall_status,  # 整体状态&#10;            'defect_reasons': defect_reasons,  # 缺陷原因&#10;            'inverted_count': inverted_count,  # 颠倒标签数量&#10;            'ok1_count': ok1_count,  # ok1商标数量&#10;            'ok2_count': ok2_count,  # ok2商标数量&#10;            'velcro_count': velcro_count,  # 魔术贴数量&#10;            'total_detections': len(detections),  # 总检测数量&#10;            'product_type': self.product_type,  # 产品类型&#10;            'required_classes': required_classes  # 必需的类别&#10;        }&#10;        &#10;        # 记录详细的检测信息&#10;        if self.logger:&#10;            self.logger.info(f&quot;产品类型: {self.product_type}&quot;)&#10;            self.logger.info(f&quot;检测到: ok1={ok1_count}, ok2={ok2_count}, 魔术贴={velcro_count}, 颠倒={inverted_count}&quot;)&#10;            self.logger.info(f&quot;整体状态: {overall_status}&quot;)&#10;            if defect_reasons:&#10;                self.logger.info(f&quot;缺陷原因: {', '.join(defect_reasons)}&quot;)&#10;&#10;        # 根据整体状态更新每个检测结果&#10;        for detection in detections:&#10;            class_id = detection['class_id']  # 获取类别ID&#10;            &#10;            if class_id in [0, 1]:  # 颠倒标签&#10;                detection['status'] = 'ng'&#10;                detection['color'] = (0, 0, 255)  # 红色&#10;                detection['defect_type'] = '商标颠倒'&#10;                detection['reason'] = '商标颠倒'&#10;            elif class_id in [2, 3]:  # 正常标签&#10;                detection['status'] = 'ok' if overall_status == 'ok' else 'ng'&#10;                detection['color'] = (0, 255, 0) if overall_status == 'ok' else (0, 0, 255)&#10;                # 根据检测结果设置缺陷类型&#10;                if overall_status == 'ok':&#10;                    detection['defect_type'] = None&#10;                    detection['reason'] = None&#10;                else:&#10;                    detection['defect_type'] = ', '.join(defect_reasons) if defect_reasons else '未知缺陷'&#10;                    detection['reason'] = detection['defect_type']&#10;            elif class_id == 4:  # 魔术贴&#10;                detection['status'] = 'ok' if overall_status == 'ok' else 'ng'&#10;                detection['color'] = (0, 255, 0) if overall_status == 'ok' else (0, 0, 255)&#10;                # 根据检测结果设置缺陷类型&#10;                if overall_status == 'ok':&#10;                    detection['defect_type'] = None&#10;                    detection['reason'] = None&#10;                else:&#10;                    detection['defect_type'] = ', '.join(defect_reasons) if defect_reasons else '未知缺陷'&#10;                    detection['reason'] = detection['defect_type']&#10;            else:&#10;                # 其他类别（不期望出现），统一按NG处理&#10;                detection['status'] = 'ng'&#10;                detection['color'] = (0, 0, 255)&#10;                detection['defect_type'] = '未知缺陷'&#10;                detection['reason'] = '未知缺陷'&#10;            &#10;            # 添加分析结果到每个检测&#10;            detection['analysis'] = analysis_result&#10;        &#10;        return detections&#10;&#10;    def draw_results(self, image: np.ndarray, results: List[Dict]) -&gt; np.ndarray:&#10;        &quot;&quot;&quot;在图像上绘制YOLO检测结果&quot;&quot;&quot;&#10;        img_result = image.copy()&#10;        &#10;        for result in results:&#10;            color = result.get('color', (0, 255, 0))  # 从结果中获取颜色，如果没有则默认为绿色&#10;            bbox = result['bbox']&#10;            x1, y1, x2, y2 = bbox&#10;            &#10;            # 绘制边界框&#10;            cv2.rectangle(img_result, (x1, y1), (x2, y2), color, 3)&#10;            &#10;            # 准备标签文本&#10;            detection_type = result.get('detection_type', 'Unknown')  # 获取检测类型，如果没有则默认为'Unknown'&#10;            confidence = result.get('confidence', 0.0)  # 获取置信度，如果没有则默认为0.0&#10;            label = f&quot;{detection_type}: {confidence:.2f}&quot;  # 准备标签文本，格式为 &quot;检测类型: 置信度&quot;&#10;            # 绘制标签文字&#10;            cv2.putText(img_result, label, (x1, y1 + 15),&#10;                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)&#10;        &#10;        return img_result" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Trademark detection/app/core/voice_alarm.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Trademark detection/app/core/voice_alarm.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;语音报警模块&#10;提供清晰的中文语音报警功能&#10;&quot;&quot;&quot;&#10;import os&#10;import sys&#10;import threading&#10;from typing import List&#10;import time&#10;import queue&#10;&#10;try:&#10;    import pyttsx3&#10;    PYTTSX3_AVAILABLE = True&#10;except ImportError:&#10;    PYTTSX3_AVAILABLE = False&#10;&#10;try:&#10;    # macOS系统的say命令&#10;    import subprocess&#10;    MACOS_SAY_AVAILABLE = True&#10;except:&#10;    MACOS_SAY_AVAILABLE = False&#10;&#10;&#10;class VoiceAlarm:&#10;    &quot;&quot;&quot;语音报警器&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.alarm_enabled = True&#10;        self.completion_voice_enabled = True  # 检测完成语音开关&#10;        self.text_queue = queue.Queue()&#10;        self.is_playing = False&#10;        self.lock = threading.Lock()&#10;&#10;        # 定义报警消息映射&#10;        self.alarm_messages = {&#10;            &quot;商标颠倒&quot;: &quot;商标颠倒&quot;,&#10;            &quot;魔术贴缺失&quot;: &quot;魔术贴缺失&quot;,&#10;            &quot;商标缺失&quot;: &quot;商标缺失&quot;,&#10;            &quot;本批次已满&quot;: &quot;本批次已满&quot;,&#10;            &quot;检测完成&quot;: &quot;检测完成&quot;,  # 新增检测完成消息&#10;        }&#10;&#10;        # 启动语音播放线程&#10;        self.consumer_thread = threading.Thread(target=self._voice_consumer, daemon=True)&#10;        self.consumer_thread.start()&#10;&#10;    def _voice_consumer(self):&#10;        &quot;&quot;&quot;语音播放消费者线程&quot;&quot;&quot;&#10;        while True:&#10;            try:&#10;                voice_data = self.text_queue.get(timeout=1)&#10;                if voice_data is None:  # 退出信号&#10;                    break&#10;&#10;                text, force_play = voice_data&#10;&#10;                # 检查是否应该播放&#10;                should_play = force_play&#10;                if not force_play:&#10;                    with self.lock:&#10;                        should_play = not self.is_playing&#10;&#10;                if should_play:&#10;                    with self.lock:&#10;                        self.is_playing = True&#10;&#10;                    self._speak_once(text)&#10;&#10;                    with self.lock:&#10;                        self.is_playing = False&#10;                else:&#10;                    print(f&quot;[语音] 跳过播放（正在播放中）: {text}&quot;)&#10;&#10;                self.text_queue.task_done()&#10;&#10;            except queue.Empty:&#10;                continue&#10;            except Exception as e:&#10;                print(f&quot;[语音] 消费者线程错误: {e}&quot;)&#10;&#10;    def _speak_once(self, text):&#10;        &quot;&quot;&quot;播放一次语音（每次都重新初始化引擎）&quot;&quot;&quot;&#10;        success = False&#10;        full_message = f&quot;注意！{text}！&quot;&#10;&#10;        # 优先使用macOS的say命令&#10;        if sys.platform == 'darwin':  # macOS&#10;            success = self._speak_with_macos_say(full_message)&#10;            if success:&#10;                print(f&quot;[语音] macOS say播放成功: {full_message}&quot;)&#10;&#10;        # 如果macOS say失败或不是macOS系统，使用pyttsx3&#10;        if not success and PYTTSX3_AVAILABLE:&#10;            success = self._speak_with_pyttsx3_once(full_message)&#10;            if success:&#10;                print(f&quot;[语音] pyttsx3播放成功: {full_message}&quot;)&#10;&#10;        if not success:&#10;            print(f&quot;[语音] 语音播放失败: {full_message}&quot;)&#10;            self._play_system_beep()&#10;&#10;    def _speak_with_pyttsx3_once(self, text: str):&#10;        &quot;&quot;&quot;使用pyttsx3播放语音（每次重新初始化）&quot;&quot;&quot;&#10;        if not PYTTSX3_AVAILABLE:&#10;            return False&#10;&#10;        try:&#10;            # 每次都重新初始化引擎&#10;            engine = pyttsx3.init()&#10;&#10;            # 配置语音参数&#10;            engine.setProperty('rate', 200)&#10;            engine.setProperty('volume', 0.9)&#10;&#10;            # 尝试设置中文语音&#10;            voices = engine.getProperty('voices')&#10;            if voices:&#10;                chinese_voice = None&#10;                for voice in voices:&#10;                    voice_name = voice.name.lower()&#10;                    voice_id = voice.id.lower()&#10;                    # Windows中文语音标识&#10;                    if any(keyword in voice_name or keyword in voice_id for keyword in&#10;                          ['chinese', 'mandarin', 'tingting', 'sinji', 'xiaoxiao', 'huihui', 'yaoyao']):&#10;                        chinese_voice = voice.id&#10;                        break&#10;&#10;                if chinese_voice:&#10;                    engine.setProperty('voice', chinese_voice)&#10;&#10;            engine.say(text)&#10;            engine.runAndWait()&#10;            engine.stop()  # 确保引擎停止&#10;            del engine  # 删除引擎引用&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;[语音] pyttsx3播放失败: {e}&quot;)&#10;            return False&#10;&#10;    def _speak_with_macos_say(self, text: str):&#10;        &quot;&quot;&quot;使用macOS的say命令播放语音&quot;&quot;&quot;&#10;        if not MACOS_SAY_AVAILABLE:&#10;            return False&#10;&#10;        try:&#10;            # 使用macOS的say命令，指定中文语音&#10;            result = subprocess.run([&#10;                'say', '-v', 'Tingting', text&#10;            ], capture_output=True, text=True, timeout=10)&#10;&#10;            if result.returncode == 0:&#10;                return True&#10;            else:&#10;                # 如果Tingting语音不可用，使用默认语音&#10;                result = subprocess.run([&#10;                    'say', text&#10;                ], capture_output=True, text=True, timeout=10)&#10;                return result.returncode == 0&#10;&#10;        except Exception as e:&#10;            print(f&quot;[语音] macOS say命令失败: {e}&quot;)&#10;            return False&#10;&#10;    def _get_alarm_message(self, defect_reasons: List[str]) -&gt; str:&#10;        &quot;&quot;&quot;根据缺陷原因获取报警消息&quot;&quot;&quot;&#10;        if not defect_reasons:&#10;            return &quot;产品异常&quot;&#10;&#10;        # 处理多个缺陷原因&#10;        messages = set()&#10;&#10;        for reason in defect_reasons:&#10;            # 检查是否匹配预定义的报警消息&#10;            matched = False&#10;            for key, message in self.alarm_messages.items():&#10;                if key in reason:&#10;                    messages.add(message)&#10;                    matched = True&#10;                    break&#10;&#10;            # 如果没有匹配，使用默认消息&#10;            if not matched:&#10;                if &quot;颠倒&quot; in reason or &quot;倒置&quot; in reason:&#10;                    messages.add(&quot;商标颠倒&quot;)&#10;                elif &quot;魔术贴&quot; in reason and &quot;缺失&quot; in reason:&#10;                    messages.add(&quot;魔术贴缺失&quot;)&#10;                elif &quot;商标&quot; in reason and &quot;缺失&quot; in reason:&#10;                    messages.add(&quot;商标缺失&quot;)&#10;                elif &quot;标签&quot; in reason and (&quot;缺失&quot; in reason or &quot;未检测&quot; in reason):&#10;                    messages.add(&quot;商标缺失&quot;)&#10;                else:&#10;                    messages.add(&quot;产品异常&quot;)&#10;&#10;        # 合并消息&#10;        if len(messages) == 1:&#10;            return list(messages)[0]&#10;        else:&#10;            return &quot;，&quot;.join(messages)&#10;&#10;    def trigger_alarm(self, defect_reasons: List[str] = None, batch_full: bool = False):&#10;        &quot;&quot;&quot;触发语音报警&quot;&quot;&quot;&#10;        if not self.alarm_enabled:&#10;            return&#10;&#10;        # 批次满报警优先级最高，强制播放&#10;        if batch_full:&#10;            alarm_message = &quot;本批次已满&quot;&#10;            print(f&quot;[语音] 批次满报警: {alarm_message}&quot;)&#10;            self.text_queue.put((alarm_message, True))  # True表示强制播放&#10;            return&#10;&#10;        # 产品缺陷报警&#10;        alarm_message = self._get_alarm_message(defect_reasons)&#10;        print(f&quot;[语音] 触发报警: {alarm_message}&quot;)&#10;        self.text_queue.put((alarm_message, False))  # False表示不强制播放&#10;&#10;    def trigger_batch_full_alarm(self):&#10;        &quot;&quot;&quot;触发批次满报警&quot;&quot;&quot;&#10;        self.trigger_alarm(batch_full=True)&#10;&#10;    def trigger_defect_alarm(self, defect_reasons: List[str]):&#10;        &quot;&quot;&quot;触发产品缺陷报警&quot;&quot;&quot;&#10;        self.trigger_alarm(defect_reasons=defect_reasons, batch_full=False)&#10;&#10;    def _play_system_beep(self):&#10;        &quot;&quot;&quot;播放系统提示音作为备用方案&quot;&quot;&quot;&#10;        try:&#10;            if sys.platform == 'darwin':  # macOS&#10;                os.system('afplay /System/Library/Sounds/Sosumi.aiff')&#10;            elif sys.platform == 'win32':  # Windows&#10;                import winsound&#10;                winsound.Beep(1000, 500)  # 1000Hz，持续500ms&#10;            else:  # Linux&#10;                os.system('paplay /usr/share/sounds/alsa/Front_Left.wav 2&gt;/dev/null || echo -e &quot;\a&quot;')&#10;        except:&#10;            # 最后的备用方案：终端响铃&#10;            print('\a')&#10;&#10;    def test_voice(self):&#10;        &quot;&quot;&quot;测试语音功能&quot;&quot;&quot;&#10;        test_messages = [&quot;商标颠倒&quot;, &quot;魔术贴缺失&quot;, &quot;商标缺失&quot;, &quot;本批次已满&quot;]&#10;&#10;        print(&quot;[语音] 开始语音测试...&quot;)&#10;        for i, message in enumerate(test_messages):&#10;            print(f&quot;[语音] 测试播放 {i+1}: {message}&quot;)&#10;            self.text_queue.put((message, False))&#10;            time.sleep(1)  # 等待1秒&#10;        print(&quot;[语音] 语音测试完成&quot;)&#10;&#10;    def is_busy(self):&#10;        &quot;&quot;&quot;检查是否正在播放或有待播放内容&quot;&quot;&quot;&#10;        with self.lock:&#10;            return self.is_playing or not self.text_queue.empty()&#10;&#10;    def wait_until_done(self):&#10;        &quot;&quot;&quot;等待所有语音播放完成&quot;&quot;&quot;&#10;        self.text_queue.join()&#10;&#10;    def set_alarm_enabled(self, enabled: bool):&#10;        &quot;&quot;&quot;启用/禁用报警&quot;&quot;&quot;&#10;        self.alarm_enabled = enabled&#10;        status = &quot;启用&quot; if enabled else &quot;禁用&quot;&#10;        print(f&quot;[语音] 报警已{status}&quot;)&#10;&#10;    def is_alarm_enabled(self) -&gt; bool:&#10;        &quot;&quot;&quot;检查报警是否启用&quot;&quot;&quot;&#10;        return self.alarm_enabled&#10;&#10;    def stop(self):&#10;        &quot;&quot;&quot;停止语音播放&quot;&quot;&quot;&#10;        self.text_queue.put(None)&#10;&#10;&#10;# 全局语音报警实例&#10;voice_alarm_instance = None&#10;&#10;def get_voice_alarm():&#10;    &quot;&quot;&quot;获取语音报警实例（单例模式）&quot;&quot;&quot;&#10;    global voice_alarm_instance&#10;    if voice_alarm_instance is None:&#10;        voice_alarm_instance = VoiceAlarm()&#10;    return voice_alarm_instance&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;语音报警模块&#10;提供清晰的中文语音报警功能&#10;&quot;&quot;&quot;&#10;import os&#10;import sys&#10;import threading&#10;from typing import List&#10;import time&#10;import queue&#10;&#10;try:&#10;    import pyttsx3&#10;    PYTTSX3_AVAILABLE = True&#10;except ImportError:&#10;    PYTTSX3_AVAILABLE = False&#10;&#10;try:&#10;    # macOS系统的say命令&#10;    import subprocess&#10;    MACOS_SAY_AVAILABLE = True&#10;except:&#10;    MACOS_SAY_AVAILABLE = False&#10;&#10;&#10;class VoiceAlarm:&#10;    &quot;&quot;&quot;语音报警器&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.alarm_enabled = True&#10;        self.completion_voice_enabled = True  # 检测完成语音开关&#10;        self.text_queue = queue.Queue()&#10;        self.is_playing = False&#10;        self.lock = threading.Lock()&#10;&#10;        # 定义报警消息映射&#10;        self.alarm_messages = {&#10;            &quot;商标颠倒&quot;: &quot;商标颠倒&quot;,&#10;            &quot;魔术贴缺失&quot;: &quot;魔术贴缺失&quot;,&#10;            &quot;商标缺失&quot;: &quot;商标缺失&quot;,&#10;            &quot;本批次已满&quot;: &quot;本批次已满&quot;,&#10;            &quot;检测完成&quot;: &quot;检测完成&quot;,  # 新增检测完成消息&#10;        }&#10;&#10;        # 启动语音播放线程&#10;        self.consumer_thread = threading.Thread(target=self._voice_consumer, daemon=True)&#10;        self.consumer_thread.start()&#10;&#10;    def _voice_consumer(self):&#10;        &quot;&quot;&quot;语音播放消费者线程&quot;&quot;&quot;&#10;        while True:&#10;            try:&#10;                voice_data = self.text_queue.get(timeout=1)&#10;                if voice_data is None:  # 退出信号&#10;                    break&#10;&#10;                text, force_play = voice_data&#10;&#10;                # 检查是否应该播放&#10;                should_play = force_play&#10;                if not force_play:&#10;                    with self.lock:&#10;                        should_play = not self.is_playing&#10;&#10;                if should_play:&#10;                    with self.lock:&#10;                        self.is_playing = True&#10;&#10;                    self._speak_once(text)&#10;&#10;                    with self.lock:&#10;                        self.is_playing = False&#10;                else:&#10;                    print(f&quot;[语音] 跳过播放（正在播放中）: {text}&quot;)&#10;&#10;                self.text_queue.task_done()&#10;&#10;            except queue.Empty:&#10;                continue&#10;            except Exception as e:&#10;                print(f&quot;[语音] 消费者线程错误: {e}&quot;)&#10;&#10;    def _speak_once(self, text):&#10;        &quot;&quot;&quot;播放一次语音（每次都重新初始化引擎）&quot;&quot;&quot;&#10;        success = False&#10;        full_message = f&quot;注意！{text}！&quot;&#10;&#10;        # 优先使用macOS的say命令&#10;        if sys.platform == 'darwin':  # macOS&#10;            success = self._speak_with_macos_say(full_message)&#10;            if success:&#10;                print(f&quot;[语音] macOS say播放成功: {full_message}&quot;)&#10;&#10;        # 如果macOS say失败或不是macOS系统，使用pyttsx3&#10;        if not success and PYTTSX3_AVAILABLE:&#10;            success = self._speak_with_pyttsx3_once(full_message)&#10;            if success:&#10;                print(f&quot;[语音] pyttsx3播放成功: {full_message}&quot;)&#10;&#10;        if not success:&#10;            print(f&quot;[语音] 语音播放失败: {full_message}&quot;)&#10;            self._play_system_beep()&#10;&#10;    def _speak_with_pyttsx3_once(self, text: str):&#10;        &quot;&quot;&quot;使用pyttsx3播放语音（每次重新初始化）&quot;&quot;&quot;&#10;        if not PYTTSX3_AVAILABLE:&#10;            return False&#10;&#10;        try:&#10;            # 每次都重新初始化引擎&#10;            engine = pyttsx3.init()&#10;&#10;            # 配置语音参数&#10;            engine.setProperty('rate', 200)&#10;            engine.setProperty('volume', 0.9)&#10;&#10;            # 尝试设置中文语音&#10;            voices = engine.getProperty('voices')&#10;            if voices:&#10;                chinese_voice = None&#10;                for voice in voices:&#10;                    voice_name = voice.name.lower()&#10;                    voice_id = voice.id.lower()&#10;                    # Windows中文语音标识&#10;                    if any(keyword in voice_name or keyword in voice_id for keyword in&#10;                          ['chinese', 'mandarin', 'tingting', 'sinji', 'xiaoxiao', 'huihui', 'yaoyao']):&#10;                        chinese_voice = voice.id&#10;                        break&#10;&#10;                if chinese_voice:&#10;                    engine.setProperty('voice', chinese_voice)&#10;&#10;            engine.say(text)&#10;            engine.runAndWait()&#10;            engine.stop()  # 确保引擎停止&#10;            del engine  # 删除引擎引用&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;[语音] pyttsx3播放失败: {e}&quot;)&#10;            return False&#10;&#10;    def _speak_with_macos_say(self, text: str):&#10;        &quot;&quot;&quot;使用macOS的say命令播放语音&quot;&quot;&quot;&#10;        if not MACOS_SAY_AVAILABLE:&#10;            return False&#10;&#10;        try:&#10;            # 使用macOS的say命令，指定中文语音&#10;            result = subprocess.run([&#10;                'say', '-v', 'Tingting', text&#10;            ], capture_output=True, text=True, timeout=10)&#10;&#10;            if result.returncode == 0:&#10;                return True&#10;            else:&#10;                # 如果Tingting语音不可用，使用默认语音&#10;                result = subprocess.run([&#10;                    'say', text&#10;                ], capture_output=True, text=True, timeout=10)&#10;                return result.returncode == 0&#10;&#10;        except Exception as e:&#10;            print(f&quot;[语音] macOS say命令失败: {e}&quot;)&#10;            return False&#10;&#10;    def _get_alarm_message(self, defect_reasons: List[str]) -&gt; str:&#10;        &quot;&quot;&quot;根据缺陷原因获取报警消息&quot;&quot;&quot;&#10;        if not defect_reasons:&#10;            return &quot;产品异常&quot;&#10;&#10;        # 处理多个缺陷原因&#10;        messages = set()&#10;&#10;        for reason in defect_reasons:&#10;            # 检查是否匹配预定义的报警消息&#10;            matched = False&#10;            for key, message in self.alarm_messages.items():&#10;                if key in reason:&#10;                    messages.add(message)&#10;                    matched = True&#10;                    break&#10;&#10;            # 如果没有匹配，使用默认消息&#10;            if not matched:&#10;                if &quot;颠倒&quot; in reason or &quot;倒置&quot; in reason:&#10;                    messages.add(&quot;商标颠倒&quot;)&#10;                elif &quot;魔术贴&quot; in reason and &quot;缺失&quot; in reason:&#10;                    messages.add(&quot;魔术贴缺失&quot;)&#10;                elif &quot;商标&quot; in reason and &quot;缺失&quot; in reason:&#10;                    messages.add(&quot;商标缺失&quot;)&#10;                elif &quot;标签&quot; in reason and (&quot;缺失&quot; in reason or &quot;未检测&quot; in reason):&#10;                    messages.add(&quot;商标缺失&quot;)&#10;                else:&#10;                    messages.add(&quot;产品异常&quot;)&#10;&#10;        # 合并消息&#10;        if len(messages) == 1:&#10;            return list(messages)[0]&#10;        else:&#10;            return &quot;，&quot;.join(messages)&#10;&#10;    def trigger_alarm(self, defect_reasons: List[str] = None, batch_full: bool = False):&#10;        &quot;&quot;&quot;触发语音报警&quot;&quot;&quot;&#10;        if not self.alarm_enabled:&#10;            return&#10;&#10;        # 批次满报警优先级最高，强制播放&#10;        if batch_full:&#10;            alarm_message = &quot;本批次已满&quot;&#10;            print(f&quot;[语音] 批次满报警: {alarm_message}&quot;)&#10;            self.text_queue.put((alarm_message, True))  # True表示强制播放&#10;            return&#10;&#10;        # 产品缺陷报警&#10;        alarm_message = self._get_alarm_message(defect_reasons)&#10;        print(f&quot;[语音] 触发报警: {alarm_message}&quot;)&#10;        self.text_queue.put((alarm_message, False))  # False表示不强制播放&#10;&#10;    def trigger_batch_full_alarm(self):&#10;        &quot;&quot;&quot;触发批次满报警&quot;&quot;&quot;&#10;        self.trigger_alarm(batch_full=True)&#10;&#10;    def trigger_defect_alarm(self, defect_reasons: List[str]):&#10;        &quot;&quot;&quot;触发产品缺陷报警&quot;&quot;&quot;&#10;        self.trigger_alarm(defect_reasons=defect_reasons, batch_full=False)&#10;&#10;    def trigger_completion_voice(self):&#10;        &quot;&quot;&quot;触发检测完成语音提示（最高优先级）&quot;&quot;&quot;&#10;        if not self.completion_voice_enabled:&#10;            return&#10;        &#10;        print(&quot;[语音] 触发检测完成语音提示&quot;)&#10;        # 设置为最高优先级，强制播放&#10;        self.text_queue.put((&quot;检测完成&quot;, True))&#10;&#10;    def set_completion_voice_enabled(self, enabled: bool):&#10;        &quot;&quot;&quot;设置检测完成语音开关&quot;&quot;&quot;&#10;        self.completion_voice_enabled = enabled&#10;        status = &quot;启用&quot; if enabled else &quot;禁用&quot;&#10;        print(f&quot;[语音] 检测完成语音已{status}&quot;)&#10;&#10;    def is_completion_voice_enabled(self) -&gt; bool:&#10;        &quot;&quot;&quot;检查检测完成语音是否启用&quot;&quot;&quot;&#10;        return self.completion_voice_enabled&#10;&#10;    def _play_system_beep(self):&#10;        &quot;&quot;&quot;播放系统提示音作为备用方案&quot;&quot;&quot;&#10;        try:&#10;            if sys.platform == 'darwin':  # macOS&#10;                os.system('afplay /System/Library/Sounds/Sosumi.aiff')&#10;            elif sys.platform == 'win32':  # Windows&#10;                import winsound&#10;                winsound.Beep(1000, 500)  # 1000Hz，持续500ms&#10;            else:  # Linux&#10;                os.system('paplay /usr/share/sounds/alsa/Front_Left.wav 2&gt;/dev/null || echo -e &quot;\a&quot;')&#10;        except:&#10;            # 最后的备用方案：终端响铃&#10;            print('\a')&#10;&#10;    def test_voice(self):&#10;        &quot;&quot;&quot;测试语音功能&quot;&quot;&quot;&#10;        test_messages = [&quot;商标颠倒&quot;, &quot;魔术贴缺失&quot;, &quot;商标缺失&quot;, &quot;本批次已满&quot;]&#10;&#10;        print(&quot;[语音] 开始语音测试...&quot;)&#10;        for i, message in enumerate(test_messages):&#10;            print(f&quot;[语音] 测试播放 {i+1}: {message}&quot;)&#10;            self.text_queue.put((message, False))&#10;            time.sleep(1)  # 等待1秒&#10;        print(&quot;[语音] 语音测试完成&quot;)&#10;&#10;    def is_busy(self):&#10;        &quot;&quot;&quot;检查是否正在播放或有待播放内容&quot;&quot;&quot;&#10;        with self.lock:&#10;            return self.is_playing or not self.text_queue.empty()&#10;&#10;    def wait_until_done(self):&#10;        &quot;&quot;&quot;等待所有语音播放完成&quot;&quot;&quot;&#10;        self.text_queue.join()&#10;&#10;    def set_alarm_enabled(self, enabled: bool):&#10;        &quot;&quot;&quot;启用/禁用报警&quot;&quot;&quot;&#10;        self.alarm_enabled = enabled&#10;        status = &quot;启用&quot; if enabled else &quot;禁用&quot;&#10;        print(f&quot;[语音] 报警已{status}&quot;)&#10;&#10;    def is_alarm_enabled(self) -&gt; bool:&#10;        &quot;&quot;&quot;检查报警是否启用&quot;&quot;&quot;&#10;        return self.alarm_enabled&#10;&#10;    def stop(self):&#10;        &quot;&quot;&quot;停止语音播放&quot;&quot;&quot;&#10;        self.text_queue.put(None)&#10;&#10;&#10;# 全局语音报警实例&#10;voice_alarm_instance = None&#10;&#10;def get_voice_alarm():&#10;    &quot;&quot;&quot;获取语音报警实例（单例模式）&quot;&quot;&quot;&#10;    global voice_alarm_instance&#10;    if voice_alarm_instance is None:&#10;        voice_alarm_instance = VoiceAlarm()&#10;    return voice_alarm_instance" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>